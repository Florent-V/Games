# Documentation Technique Complète du Jeu 2048

Bienvenue dans la documentation technique du jeu 2048 que j’ai développé.  
L’objectif est de passer en revue chaque fichier et chaque morceau de code important pour comprendre **comment** le jeu fonctionne, mais aussi **pourquoi** j’ai fait certains choix techniques.

## 1. Philosophie et Choix d’Architecture

J’ai voulu garder une approche claire avec une **séparation des responsabilités** bien définie.  
Le choix technologique principal repose sur **le DOM (Document Object Model) pour le rendu**, combiné avec **les animations en CSS**.

- **Pourquoi le DOM ?**  
  La grille de 4x4 ne peut contenir que 16 tuiles au maximum. C’est très peu, et le navigateur peut gérer ça sans aucun souci de performance. En utilisant le DOM, je peux exploiter toute la puissance du CSS pour le style et les animations.
- **Pourquoi les animations CSS ?**  
  Le CSS moderne permet des animations fluides et optimisées matériellement (“hardware-accelerated”). Définir une `transition` sur `transform` est un moyen performant et déclaratif pour animer un déplacement.

## 2. Structure du Projet

Voici la structure des fichiers importants avec leur rôle :

```
/src/games/2048/
├── components/         # Composants Vue pour l’affichage
│   ├── GameBoard.vue   # La grille de fond, gère aussi les interactions tactiles
│   └── GameTile.vue    # Une tuile numérotée, cœur de l’animation
├── composables/        # Logique réactive et interface
│   ├── useGame.ts          # Gère le déroulement du jeu, score et animations
│   ├── useInputHandler.ts  # Gère les entrées clavier
│   └── usePersistence.ts   # Sauvegarde et chargement de la partie
├── state/              # Logique pure et état du jeu
│   ├── Grid.ts         # Moteur du jeu : mouvements, gestion des tuiles
│   └── Tile.ts         # Classe représentant une tuile
├── views/              # Vue principale assemblant le jeu
│   └── GameView.vue
├── constants.ts        # Constantes du jeu (taille de la grille, etc.)
├── types.ts            # Types TypeScript
└── game-2048.css       # Styles et animations CSS
```

---

## 3. Analyse Détaillée par Fichier

### `state/Tile.ts`

Ce fichier définit la structure de données d’une tuile.  
C’est la plus petite brique du jeu.

```typescript
export class Tile {
  static nextId = 1; // Compteur global pour IDs uniques

  id: number;         // ID unique pour le `:key` de Vue
  value: number;      // Valeur affichée (2, 4, 8, ...)
  row: number;        // Ligne actuelle (0-3)
  col: number;        // Colonne actuelle (0-3)
  merged: boolean;    // La tuile vient-elle d’une fusion ?
  prevRow?: number;   // Ligne précédente (pour l’animation)
  prevCol?: number;   // Colonne précédente (pour l’animation)

  constructor(row: number, col: number, value?: number) {
    this.id = Tile.nextId++;
    // ...
  }
}
```

- **`prevRow` / `prevCol`** → essentiels pour les animations de déplacement.
- **`merged`** → permet de déclencher l’animation “pop” sur une fusion.

### `state/Grid.ts`

C’est le moteur du jeu.  
Il ne gère pas l’affichage, uniquement la logique.

- **`move(dir)`** : Fonction clé.  
  Exemple pour un mouvement vers la **droite** :

  1. **`buildTraversals(vector)`** :  
     Pour la droite, le vecteur est `{x: 1, y: 0}`.  
     On itère les colonnes dans l’ordre `[3, 2, 1, 0]` afin de traiter d’abord les tuiles les plus à droite.  
     Cela empêche une tuile de fusionner plusieurs fois dans le même tour.

  2. **Boucle principale** :  
     Parcours de chaque case avec l’ordre défini.

  3. **`findFarthestPosition(tile, vector)`** :  
     Détermine jusqu’où la tuile peut glisser et identifie la prochaine tuile rencontrée.

  4. **Fusion** :  
     Si la tuile rencontrée a la même valeur et n’a pas déjà fusionné dans ce tour :
     - On déplace la tuile sur cette position.
     - On marque la tuile rencontrée comme `merged = true`.

  5. **`applyMerges()`** :  
     Appelée **après** l’animation pour doubler la valeur des tuiles fusionnées et supprimer celles absorbées.

### `composables/useGame.ts`

Ce fichier orchestre la logique du `Grid` et gère les tours côté Vue.

- **Gestion des animations** :  
  Chaque tour n’est terminé que lorsque les animations sont finies.

```typescript
function move(dir: Direction) {
  if (animating.value) return; // Bloquer si animation en cours

  const result = grid.move(dir);
  if (result.moved) {
    animating.value = true;
    setTimeout(() => {
      grid.applyMerges();      // 1. Appliquer les fusions
      grid.spawnRandomTile();  // 2. Ajouter une nouvelle tuile
      animating.value = false; // 3. Autoriser un nouveau mouvement
    }, ANIMATION_DURATION);
  }
}
```

Le `setTimeout` laisse le temps au CSS de jouer le déplacement avant la mise à jour de la grille.

### `components/GameTile.vue`

Ce composant fait le lien entre la logique et le rendu visuel.

- **`positionStyle`** : Fournit les positions (ancienne et nouvelle) sous forme de variables CSS (`--from-row`, `--to-row`, etc.).
- **`tileClass`** : Ajoute des classes en fonction de l’état (`.new`, `.merged`…) pour déclencher les animations correspondantes.

### `game-2048.css`

Gère toutes les animations et styles.

- **Déplacement** :
```css
.tile {
  --x-from: calc(var(--from-col) * ...);
  --y-from: calc(var(--from-row) * ...);
  --x-to: calc(var(--to-col) * ...);
  --y-to: calc(var(--to-row) * ...);

  transform: translate(var(--x-from), var(--y-from));
  transition: transform var(--anim-duration) ease;
}

.tile:not(.new) {
  transform: translate(var(--x-to), var(--y-to));
}
```
Le `transition` CSS gère automatiquement l’animation entre position initiale et finale.

- **Animations avancées (`@keyframes`)** :  
  `spawn` et `pop` sont appliquées via `.new` et `.merged` pour les effets d’apparition et de fusion.

---

Avec cette explication, vous avez une vision complète et claire du fonctionnement interne du jeu 2048 que j’ai codé.
